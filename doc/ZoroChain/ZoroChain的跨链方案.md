# 跨链实现
目前 NEO 和 Zoro 间的跨链通信(转账)通过智能合约存取资产和第三方管理程序转发交易来实现，因为 NEO 已经运行无法修改，只能依靠其现有机制来实现，但是这种方式全部依赖管理程序，安全性不够而且完全受中心化控制。

Zoro 目前还处在设计开发中，所以根链和应用链之间可以设计其他的跨链方案。

主要考虑因素：
* 保证跨链交易的原子性，要保证跨链双方都交易成功/失败；
* 一条链可以对另一条链的交易进行验证，B 链可以验证 A 链的一笔交易，验证通过后才可以在 B 链做相应的交易；
* 保证两条链的资产总量不变，A 转移一笔资产到 B 链，A 链资产减少，B 链对应资产增加；
* 两条链独立安全，一条链受到攻击时不影响与之通信的另一条链；


目前考虑的方案有以下几种：

1、沿用 NEO 和 Zoro 的跨链方案；A 链上往特定合约地址转一笔资产，产生 ApplicationLog，第三方管理程序监控 A 的区块数据，发现这笔转账后往 B 上发起一笔交易，实现跨链通信，这样交易的验证都通过管理程序完成，需要考虑安全性；收取钱的交易也是管理程序去签名，完全中心化。

2、1 的改进版，先实现跨链读取数据，这样管理程序只做监控和发起交易，跨链交易的验证部分由合约完成，不需要固定的管理者签名，安全性和去中心化都有所提升，但需要保证验证交易时目标链的高度一致（状态一致）。A 链上发起一笔到 B 链的转账，监控程序看到后转发给 B 链，B 链读取验证 A 链的该笔交易信息，做出相应的处理，需要考虑的是如何保证 B 链的每个节点去 A 链读取数据时，它请求的 A 链节点区块已经包含了该笔交易，如果高度还没到时则需要等待，如何设置等待机制？

3、通过投递的方式，应用链间的跨链都通过与根链交互来实现，投递由共识机制来发起一笔交易实现，先在 A 链上发起一笔跨链交易，A 链的共识机制确认该交易后便往根链发一笔交易，C 链监控到了根链的这笔交易后就由共识机制往 C 链发一笔交易，完成跨链，该方案需要所有应用链都自带监控根链的功能，并且在共识部分实现发起交易的功能。



# 细化方案
## 业务：

根链有 BCP，每个应用链有自己的代币，应用链发行代币合约时需要同时在根链发布，根链上的应用链代币发到 Bank 中，随着跨链转移再释放（因为 Bancor 交易所运行在根链上），应用链和根链可以直接跨链转账，应用链之间要跨链转账的话需要应用链管理者在对方链上发布相应的代币合约去支持，转账过程通过根链间接来完成；

## 流程：

### 1、AppChainX 上的用户 AccountX 要将他在 AppChainX 上的 XCC 跨链转到 RootChain 上的 Account2 账户中：
* AccountX 先在 AppChainX 上发起一笔交易，将 XCC 存到 AppChainX 上的 XBank 中；
* AppChainX 的共识机制在确认交易该交易后便往根链发起一笔交易，调用根链的 RBank 往 Account2 账户转一笔 XCC；为保证足够安全，根链的交易可以读取 AppChainX 的数据去验证 AccountX 的交易，验证通过后才转钱，`但是每个节点上应用链的同步状态无法保证，验证也不能确保通过`；

### 2、AppChainX 上的用户 AccountX 要将他在 AppChainX 上的 XCC 兑换成 AppChainY 上的 YCC 发到 AccountY 账户里：
* AccountX 先在 AppChainX 上发起一笔交易，将 XCC 存到 AppChainX 上的 XBank 中；
* AppChainX 的共识机制在确认交易该交易后便往根链发起一笔交易，调用根链的 RBank 往 AccountX 在根链的账户转一笔 XCC，这样 AccountX 在根链拥有了 XCC；
* AccountX 在根链上的 Bancor 交易所将 XCC 兑换成 YCC（这里需要先兑换成 BCP，再用 BCP 购买 YCC）；
* AccountX 将自己在根链上买到的 YCC 转到 RBank 中；
* AppChainY 的共识机制会监控根链数据，发现根链有 YCC 转到 RBank 的交易，则当做跨链处理，便向 AppChainY 发起一笔交易，从 YBank 中转出一笔 YCC 给指定的账户 AccountY。


![](Zoro.png)
